# Устные вопросы:

### 1. Какой самый эффективный способ конкатенации строк?

Использование strings.Builder или strings.Join, который основан на нём

Строки в golang иммутабельны, потому каждое обычное сложение строк приводит к копированию.

Builder использует буфер в виде массива байт, к которому добавляются новые строки через append.		
Копирование тоже иногда происходит, но только когда нужно удвоить вместимость буфера при его переполнении.
```go
 var sb strings.Builder
 sb.WriteString("first string")
 sb.WriteString("second string")
 fmt.Println(sb.String())
```
### 2.Что такое интерфейсы, как они применяются в Go?
Интерфейс позволяет вызывающей стороне привязываться не к реализации, а только к определённому поведению (набору методов).

Интерфейс это именнованная коллекция типов.		
Он определяется набором сигнатур его методов.

В GO нет явного указания какой интерфейс реализуется типом.		
Если у типа имеются все перечисленные в данном интерфейсе методы - значит он имплементирует этот интерфейс.

Если какая-либо функция в качестве аргумента принимает интерфейс, то ей можно передать любой тип, реализующий этот интерфейс.

Цель интерфейсов в GO это уменьшение степени связности/зацепления программы.

### 3.Чем отличаются RWMutex от Mutex?
В отличии от Mutex у RWMutex помимо `Lock()/Unlock()` есть отдельные аналогичные методы только для чтения — `RLock()/RUnlock()`. 		
Если метод нуждается только в чтении — он использует `RLock()`, который не заблокирует другие операции чтения, но заблокирует операцию записи и наоборот.

### 4.Чем отличаются буферизированные и не буферизированные каналы?

* Если канал не буферизован, отправитель блокируется, пока получатель не получил значение.
* Если у канала есть буфер, отправитель блокируется только до того как значение было скопировано в буфер; если буфер заполнен, это означает ожидание, пока какой-либо получатель не получит значение.

### 5.Какой размер у структуры struct{}{}?
0 байт

### 6. Есть ли в Go перегрузка методов или операторов?
Нет. Так было задумано для повышения прозрачности/читаемости кода.

### 7.В какой последовательности будут выведены элементы map[int]int?
Если выводить ключи-значения мапы через Println, то будут выводиться отсортированные значения. Сортировку выполняет Println.		
А если через цикл `for key, vaalue := range map{}`, то порядок будет случайным, обращение к случайному бакету прописано во внутреннем устройстве map. 

```go
m := make(map[int]int)  
  
m[3] = 281  
m[1] = 124  
m[0] = 1
  
for key, val := range m {  
   fmt.Println(key, val)  
  
}  
  
fmt.Println(m)
```

```
1 124
0 1
3 281
map[0:1 1:124 3:281]
```

### 8.
В чем разница make и new?

**Make** позволяет инициализиролвать 
и выделять память для slice, map, chan

new(int)- объявляет переменную типа int, инициализует её, объявляет переменную типа указатель на int (* int).

x

-   `new` would have special behaviour if the type passed to `new` was a slice, map or channel. This is a rule that every Go programmer would have to remember.
-   For slices and channels, `new` would have to become variadic, taking a possible length, buffer size, or capacity, as required. Again more special cases to have to remember, whereas before `new` took exactly one argument, the type.
-   `new` always returns a `*T` for the `T` passed to it. That would mean code like


### 9. Сколько существует способов задать переменную типа slice или map?


### 10. Что выведет данная программа и почему?


```go
func update(p *int) {
    b := 2
    p = &b
}

func main() {
    var (a = 1
        p = &a)
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}```
Out:

`1`
`1`



Указатель передаётся в функцию, но вместо обращение к значению по указателю (например `*p=b`) в локальную переменную `p` записывается другой указатель, 
потому оригинальное значение `a` не изменяется.



### 11. Что выведет данная программа и почему?



```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```

Выведутся числа от 0 до 4 в случайном порядке,
после чего наступает Deadlock.

Это происходит из-за того, что waitgroup копируется для каждой горутины когда передаём в неё её по значению.
Потому wg.Done() отрабатывает для их внутренних локальных waitgroup-ов, а для главной внешней - нет.
Чтобы всё работало корректно можно передать в горутины указатель на waigroup или вообще никак не передавать её в горутины.

### 12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```
Out:
`0`
У циклов своя локальная область видимости, потому после пересоздания `n` внутри цикла это отдельная перменная и внешнее значение не поменяется.

### 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
Out:
`[100 2 3 4 5]`

Слайсы передаются по ссылке, потому `v[0]=100` меняет значение в оригинальном слайсе.
После чего результат append пишется в реаллоцированную локальную переменную v, изменений оригинального слайса уже не происходит.

### 14. Что выведет данная программа и почему?
```go
func main() {
    slice := []string{"a", "a"}

    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```
Out:
`[b b a][a a]`

Результат append пишется в реаллоцированную локальную переменную `slice`, после чего изменения затрагивают именно этот локальный `slice`
После возвращения в `main` из функции печатается оригинальный слайс, который всё это время не изменялся.
